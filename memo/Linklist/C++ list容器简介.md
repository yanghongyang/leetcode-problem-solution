<!--
 * @Description: 
 * @Author: Hongyang_Yang
 * @Date: 2020-10-16 08:48:36
 * @LastEditors: Hongyang_Yang
 * @LastEditTime: 2020-10-16 09:05:40
-->
### 声明
以下内容摘抄自 [C++ list用法详解](https://blog.csdn.net/u011630575/article/details/79734358)。

### 简介
`list` 是一种序列式容器。`list` 容器完成的功能实际上和数据结构中的 **双向链表** 是极其相似的， `list` 中的数据元素是通过链表指针串连成逻辑意义上的线性表，即 `list` 也具有链表的主要优点，即：**在链表的任一位置进行元素的插入、删除操作都是快速的。**

ist的实现大概如下：list的每个节点有三个域： **前驱元素指针域**、 **数据域** 和 **后继元素指针域**。前驱元素指针域保存了前驱元素的首地址；数据域则是本节点的数据；后继元素指针域则保存了后继元素的首地址。

list和循环链表也有相似的地方，即： **头节点的前驱元素指针域保存的是链表中尾元素的首地址，list的尾节点的后继元素指针域则保存了头节点的首地址。** 这样，list实际上就构成了一个 **双向循环链**。

由于list元素节点并不要求在一段连续的内存中，显然在list中是 **不支持快速随机存取** 的，因此对于迭代器，只能通过“++”或“--”操作将迭代器移动到后继/前驱节点元素处。而不能对迭代器进行+n或-n的操作，这点，是与vector等不同的地方。

### List&Vector&Deque对比
|vector|list|deque|
|---|--|--|
|1. 拥有一段连续的内存空间，能非常好的支持随即存取，即[]操作符|1. 内存空间是不连续的，通过指针来进行数据的访问，没有提供[]操作符的重载。|1. 支持[]操作符，也就是支持随即存取|
|2. 当插入较多的元素后，预留内存空间可能不够，需要重新申请一块足够大的内存并把原来的数据拷贝到新的内存空间。|2. 可以以很好的效率支持任意地方的删除和插入。|2. 支持在两端的操作。|

实际使用时，根据以下原则进行三者的选取：
1. 如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector。
2. 如果你需要大量的插入和删除，而不关心随即存取，则应使用list。
3. 如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。

### list中的常用函数
#### list中的构造函数
list() 声明一个空列表。

list(n) 声明一个有n个元素的列表，每个元素都是由其默认构造函数T()构造出来的。

list(n,val) 声明一个由n个元素的列表，每个元素的值都是val得来的。

list(first,last) 声明一个列表，其元素的初始值来源于由区间所指定的序列中的元素。
#### begin()和end()
通过调用list容器的成员函数begin()得到一个指向容器起始位置的iterator，可以调用list容器的 end() 函数来得到list末端下一位置，相当于：int a[n]中的第n+1个位置a[n]，实际上是不存在的，不能访问，经常作为循环结束判断结束条件使用。

#### push_back() 和push_front()
使用list的成员函数push_back和push_front插入一个元素到list中。其中push_back()从list的末端插入，而 push_front()实现的从list的头部插入。

#### empty()
利用empty() 判断list是否为空。

#### resize()
如果调用resize(n)将list的长度改为只容纳n个元素，超出的元素将被删除，如果需要扩展那么调用默认构造函数T()将元素加到list末端。如果调用resize(n,val)，则扩展元素要调用构造函数T(val)函数进行元素构造，其余部分相同。

#### clear()
清空list中的所有元素。

#### front()和back()
通过front()可以获得list容器中的头部元素，通过back()可以获得list容器的最后一个元素。但是有一点要注意，就是list中元素是空的时候，这时候调用front()和back()会发生什么呢？实际上会发生不能正常读取数据的情况，但是这并不报错，那我们编程序时就要注意了，个人觉得在使用之前最好先调用empty()函数判断list是否为空。

#### pop_back和pop_front()
通过pop_back()删除最后一个元素，通过pop_front()删除第一个元素；序列必须不为空，如果当list为空的时候调用pop_back()和pop_front()会使程序崩掉。

#### assign()
具体和vector中的操作类似，也是有两种情况。

第一种是：l1.assign(n,val)将 l1中元素变为n个T(val）。

第二种情况是：l1.assign(l2.begin(),l2.end())将l2中的从l2.begin()到l2.end()之间的数值赋值给l1。

#### swap()
交换两个链表(两个重载)，一个是l1.swap(l2); 另外一个是swap(l1,l2)，都可能完成连个链表的交换。

#### reverse()
通过reverse()完成list的逆置。

#### merge()
合并两个链表并使之默认升序(也可改)，l1.merge(l2，greater<int>()); 调用结束后l2变为空，l1中元素包含原来l1 和 l2中的元素，并且排好序，升序。其实默认是升序，greater<int>()可以省略，另外greater<int>()是可以变的，也可以不按升序排列。

#### insert()
在指定位置插入一个或多个元素(三个重载)：

l1.insert(l1.begin(),100); 在l1的开始位置插入100。

l1.insert(l1.begin(),2,200); 在l1的开始位置插入2个100。

l1.insert(l1.begin(),l2.begin(),l2.end());在l1的开始位置插入l2的从开始到结束的所有位置的元素。

#### erase()
删除一个元素或一个区域的元素(两个重载)

l1.erase(l1.begin()); 将l1的第一个元素删除。

l1.erase(l1.begin(),l1.end()); 将l1的从begin()到end()之间的元素删除。

<!--
 * @Description: 
 * @Author: Hongyang_Yang
 * @Date: 2021-01-02 19:38:24
 * @LastEditors: Hongyang_Yang
 * @LastEditTime: 2021-01-02 20:45:28
-->
#### 考察
1. 模拟
2. 数学
3. 栈/队列（有一点点这个思想，尤其是判断能不能构成青蛙叫的时候，但仅仅是想一想......）

#### 解题思路
这篇已经写的非常精简和详细了，可以直接看这篇：[判断当前有多少个字母c](https://leetcode-cn.com/problems/minimum-number-of-frogs-croaking/solution/pan-duan-dang-qian-you-duo-shao-ge-zi-mu-c-by-simo/) 

对于本题而言，难点有两处：
1. 怎么判断字符串 `croakOfFrogs` 是否合法
2. 如何判断青蛙在同时唱歌

乍一看，相比较 `2` ，难点 `1` 相对实现起来更方便一点。因此先考虑难点 `1` 。

对于 `1` ，字符串合法的判别条件有两个：
1. 每个字母出现的次数一样
2. 每个字母都是按照 `'c' 'r' 'o' 'a' 'k'` 的顺序 **依次** 出现

何为 **“依次”** ？ 不妨试想，如果 `'c'` 出现在 `'r'` 之前，并且可能出现多个青蛙同时唱歌的情况，那么在字符串的某个字符之前，字母 `'c'` 出现的次数一定会比 `'r'` 出现的次数多。这里就将 **出现时序** 问题转化为了 **出现次数** 问题。（私以为这是本题的精妙之处）

那么再回到难点 `'1'` ，只需在遍历字符串的时候统计其字母出现的出现次数，然后比较即可。

接下来的问题是，何时比较？

已知 `“croak”` 由 `5` 个不同的字母组成，因此如果比较的话肯定是等到出现了 `'k'`，统计到 `k` 的个数，然后再比较。所以每当出现 `'k'` 的时候，进行 `5` 个字母的次数的比较。比较关系应为： `c >= r && r >= o && o >= a && a >= k`。

比较之后，如果构成了青蛙叫，那么把这组字母出现的次数都减一，表示有只青蛙叫了。只有这样处理之后才能不断遍历不断判断。

至此，难点 `1` 得到解决。接下来是难点 `2`。

通过对难点 `1` 进行分析，不难发现，如果出现了多只青蛙同时叫，那么在出现第一个 `'k'` 之前，肯定有很多个其他相同的字母，而属 `'c'` 最多（因为青蛙第一声便是 `'c'` ），那么只需要在每次出现 `'k'` 的时候统计一下此时的 `'c'` 的个数，并取每次出现 `'k'` 时， `'c'` 的次数的 **最大值** 即可。这里的正确性来源于：“如果构成了青蛙叫，那么把这组字母出现的次数都减一。” 

......如果实在不明白那就看代码吧。属实啰嗦。

#### 代码
```cpp []
class Solution
{
public:
    int minNumberOfFrogs(string croakOfFrogs)
    {
        int c = 0, r = 0, o = 0, a = 0, k = 0; //初始化，每个变量表示其代表的字母出现的个数
        int ans = 0;
        bool flag = true; //判断是否构成青蛙叫
        for (int i = 0; i < croakOfFrogs.size(); i++)
        {
            if (croakOfFrogs[i] == 'c')
                c++;
            else if (croakOfFrogs[i] == 'r')
                r++;
            else if (croakOfFrogs[i] == 'o')
                o++;
            else if (croakOfFrogs[i] == 'a')
                a++;
            if (croakOfFrogs[i] == 'k') //这个时候应该注意了，出现k意味着有个青蛙叫完了，同时也可以判断出，到底之前有多少个青蛙同时在叫（统计k之前c的个数）
            {
                k++; //k的个数+1
                ans = max(ans, c);
                if (c >= r && r >= o && o >= a && a >= k) //如果确实是个青蛙叫
                {
                    c--;
                    r--;
                    o--;
                    a--;
                    k--;
                }
            }
            //如果不构成青蛙叫，那就直接跳出并且返回-1
            if (!(c >= r && r >= o && o >= a && a >= k))
            {
                flag = false;
                break;
            }
        }
        if (!flag || (c != 0 || r != 0 || o != 0 || a != 0 || k != 0)) //不构成青蛙叫的情况，一种是五个字母没构成顺序（flag = false），另一种是遍历到最后某个字母多了
        {
            return -1;
        }
        return ans;
    }
};
```

#### 后记
这题原先思考了半天，觉得如果用队列记录下每次 `'c''r''o''a''k'`出现的位置，然后遍历这 `5` 个记录字母出现位置的队列，每次取队首元素出队进行比较就行了。但这种方法没有考虑到的点在于，题目问的是有几只青蛙，也就是说，一只青蛙可以在叫完之后继续叫，即 `"croakcroak"` 这种只能算是 `1` 只青蛙。这就把我难住了。后来看了其他题解才发现，只需要统计在出现 `'k'` 之前出现了多少次 `'c'` 就行了。这样做有其正确性，即一个青蛙不可能在叫完之前再叫。
#### 参考自
题解：[判断当前有多少个字母c](https://leetcode-cn.com/problems/minimum-number-of-frogs-croaking/solution/pan-duan-dang-qian-you-duo-shao-ge-zi-mu-c-by-simo/)
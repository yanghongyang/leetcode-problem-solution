### 考点
- 暴力

### 思路
给一个数字，如何只通过一次交换就得到最大值呢？

一开始的思路是，找到数字中最大的那个数字，然后和尽可能高的高位互换。

这种思路是错误的，拿 98368 为例，9 是不需要进行交换的，因此如果按照一开始的思路，输出的还是 98368 。

错误的点在于，尽管找到了最大的数字，但实际上需要交换的是其他数字。

因此得到了思路二：两次循环，外循环从高位到低位遍历数字的每一位，对于第 i 位上的数字，内循环向低位遍历，找到比它大的数字之后交换位置。

这种思路大体上正确，但仍然存在错误，拿 1993 为例，如果不好好处理，则会得到 9193 这个答案而不是正确答案（9913）。

因此在思路二的基础上进行纠正，应该在内循环的时候找到第 i 位之后低位里最大的，位置最低的数字，才能交换。

**代码（极为朴素）**
```cpp []
class Solution
{
public:
    int maximumSwap(int num)
    {
        vector<int> ans;
        int tmp = num;
        while (tmp > 0) //处理数字，变成字符串
        {
            int t = tmp % 10;
            ans.push_back(t);
            tmp /= 10;
        }
        int cnt = 0; //记录交换次数的
        int maxn = 0;
        int posn = 0;
        for (int i = ans.size() - 1; i >= 0; i--)
        {
            if (cnt == 1)
                break;
            maxn = ans[i];
            posn = i;
            for (int j = i - 1; j >= 0; j--)
            {
                if (maxn <= ans[j]) //找到了最大值和最大值所在的位置
                {
                    maxn = max(maxn, ans[j]);
                    posn = j;
                }
            }
            if (maxn != ans[i])
            {
                swap(ans[i], ans[posn]);
                cnt++;
            }
        }
        long long res = 0;
        for (int i = ans.size() - 1; i >= 0; i--)
        {
            res += ans[i];
            res *= 10;
        }
        res /= 10;
        return res;
    }
};
```

时间复杂度：$O(n^2)$ ，其中 n 为数字的长度。这里理解为，尽管只需要一次交换，但是最坏情况下仍然需要外内循环都遍历完数字处理后的整个数组。

空间复杂度：$O(n)$ ，这里 n 为数字的长度。
### 后记
这题用暴力法 ac 了之后，看官网上的题解，觉得都写得挺...难看懂的？虽然很多题解用了好多好多方法，但 emmm 暂时没心情看下去，因此这篇题解就这样了。不过以后复盘的时候估计会认真看吧，先 mark 一下。

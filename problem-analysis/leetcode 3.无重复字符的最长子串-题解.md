<!--
 * @Description: 
 * @Author: Hongyang_Yang
 * @Date: 2021-01-07 11:47:11
 * @LastEditors: Hongyang_Yang
 * @LastEditTime: 2021-01-07 12:21:49
-->
#### 考点
- 模拟（暴力） -> 滑动窗口

#### 题目分析
 “最长子串” 意味着它和 “最长子序列” 是不同的，子串要求字符连续。

可以在暴力模拟的基础上进行一定的优化，事实上暴力法的内层循环每次都会从外循环的起始位置开始，而这是非常不必要的。考虑第 `i` 个字符，假设此时 `i...j` 构成了以第 `i` 个字符为首的不含重复字符的最长子串，则下一次循环 `i = i + 1` ，而由 `i...j` 为不含重复字符的最长子串，可以推出，`i + 1 ... j` 也构成了不含重复字符的子串，因此 `j` 实际上可以继续向右，而不用再回归到 `i + 1` 重新遍历。

大概以上为滑动窗口/双指针（这俩我一直没搞明白区别）的思想。可以看到，滑动窗口/双指针的思想实际上基于暴力法，并对暴力法进行了优化。~~~（暴力法万岁！）~~~

理解优化思路后便可以写滑动窗口/双指针解法了。

滑动窗口/双指针的基本操作是，固定一端（通常是左指针），移动一端（通常是右指针）。符合条件的话右指针就一直向右移动，一旦发现不符合条件的情况，就对两个指针进行调整，根据题目条件，左指针可能向右移动 `1` 个或多个单位，也可能直接移动到右指针的位置（这种情况下右指针指向下一个位置或者其他位置）。

在本题中，需要考虑的点有：
1. 重复字符如何处理？   
    由于 `s` 是字符串，因此可以直接用 `vector<int> cnt(256, 0)` 作为计数器，统计每个字符出现的次数。 “无重复字符” 要求子串中元素 `k` 的次数 `cnt[s[i]] < 1` 。
2. 左右指针怎么设置？
    按本人想法，左右指针 `l` 和 `r` 的初始值就分别设置为 `0` 和 `1` ，初始化计数器 `cnt[s[l]]++` 。外层循环判断 `l` 是否超出了边界，内层右指针进行滑动。当右指针滑不下去的时候就跳出内层循环，并更新此时的最大值 `ans` 并且对左指针进行滑动。由于左指针滑动导致原先左指针指向的字符个数需要减一。

具体的情况可以看代码。

#### 代码
```cpp []
class Solution
{
public:
    int lengthOfLongestSubstring(string s)
    {
        int n = s.size();
        if (n <= 0) //因为左右指针都设置大于0，所以事先判断一下特殊情况
            return 0;
        int l = 0, r = 1;   //左右指针初始值
        int ans = 0;
        vector<int> cnt(256, 0);
        cnt[s[l]]++;
        while (l < n)
        {
            while (cnt[s[r]] < 1 && r < n)  //满足条件就一直向右滑
            {
                cnt[s[r]]++;    //更新计数器
                r++;    //向右滑
            }
            ans = max(ans, r - l);  //右指针滑不动了，更新此时的答案
            cnt[s[l]]--;    //左指针向右滑，先把原先指向的元素的计数器减1
            l++;    //左指针向右滑
        }
        return ans;
    }
};
```

时间复杂度：$O(N)$，尽管 `while` 语句中嵌套了一个 `while` 语句，但实际上每个字符仅仅被访问了一次，因此实际上只有一次遍历，时间复杂度正比于字符串 `s` 的长度（ `N` ）。

空间复杂度：$O(1)$，尽管设置了 `vector<int> cnt` ，但由于字符串仅由英文字母、数字、符号和空格组成，即 `cnt` 的规模是有限的（256），所以空间复杂度为 $O(1)$ 。

#### 后记
懒才是第一生产力。拿到这题第一个想法就是暴力模拟，先在脑子里模拟了一下，感觉太麻烦了，好多重循环，会直接导致时间复杂度上升的。然后就不想写了......（因为很多题的暴力解法实际上我并不会写......）但是振作了起来又想了想，这题除了暴力法应该还可以在暴力的基础上优化，所以就写了滑动窗口/双指针方法。

说起来滑动窗口的话，最经典的算法大概就是 **KMP** 算法了吧。属实厉害。